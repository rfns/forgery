<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Forgery.Agent">
<Super>Forgery.Agent.Core</Super>
<TimeCreated>64841,40144.236505</TimeCreated>

<Method name="Post">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set settings.method = "POST"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Get">
<FormalSpec>settings:%DynamicObject="",response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '$isobject(settings) {
    set url = settings
    set settings = { "url": (url) }
  }
  set settings.method = "GET"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Put">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set settings.method = "PUT"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Delete">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set settings.method = "DELETE"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Head">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set settings.method = "HEAD"
  set settings.data = {}
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Patch">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set settings.method = "PATCH"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>

<Method name="Options">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set settings.method = "OPTIONS"
  return ..Request(settings, .response, outputToDevice)
]]></Implementation>
</Method>
</Class>


<Class name="Forgery.Agent.Core">
<Super>%RegisteredObject</Super>
<TimeCreated>64883,42655.913833</TimeCreated>

<Property name="Cache">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Namespace">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="CookiesJar">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Namespace = $namespace
  set ..Cache = "^|"""_..Namespace_"""|Forgery.Agent"  
  return $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill @i%Cache
  return $$$OK
]]></Implementation>
</Method>

<Method name="Request">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object,outputToDevice:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  if '$isobject(settings.data) set settings.data = {}
  if '$isobject(settings.headers) set settings.headers = {}
  if '$isobject(settings.cookies) set settings.cookies = {}
  
  set settings = {
    "url": ($zconvert(settings.url, "I", "URL")), 
    "method": (settings.method), 
    "data": (settings.data),
    "headers": (settings.headers),
    "cookies": (settings.cookies)
  }
  
  $$$QuitOnError(..Forge(settings, .response))
  
  if outputToDevice = 1 do response.OutputToDevice()  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Forge">
<FormalSpec>settings:%DynamicObject,response:%Stream.Object="",outputToDevice:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill %request, %session, %response
  new %request, %session, %response  
  
  // Makes sure that any attempts to change the namespace internally ends up in the original one.
  set fromNamespace = ..Namespace
  set str = ""
  
  merge cookiesJar = i%CookiesJar
  
  set %request = ##class(Forgery.Request).CreateFromSettings(settings, .cookiesJar)
  set %session = ##class(%CSP.Session).%New(-1, 0)
  set %response = ##class(%CSP.Response).%New()  
      
  try {
    set appInfo = ..GetApplicationInfoFromUrl(%request.URL)
    set %request.Application = appInfo.AppUrl
    if $extract(%request.URL) '= "/" set %request.URL = "/"_%request.URL
    $$$ThrowOnError(##class(Forgery.OutputCapturer).Capture(appInfo.DispatchClass, %request.URL, settings.method, .response))
    do PutReceivedCookiesIntoJar
  } catch ex {    
    set sc = ex.AsStatus()
  }
  kill %request, %session, %response
  
  set $namespace = fromNamespace
  return sc
  
PutReceivedCookiesIntoJar
  set index = ""
  for {
    set index = $order(%response.Cookies(index))
    quit:index=""
    
    set name = %response.Cookies(index, "n")
    set value = %response.Cookies(index, "v")
    
    set i%CookiesJar(name, index) = value   
  }
]]></Implementation>
</Method>

<Method name="GetApplicationInfoFromUrl">
<FormalSpec>url:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
   
  #define APPCACHE @i%Cache
  
  // Cache matches to prevent roundtrips to the %SYS namespace.
  if $data($$$APPCACHE) {
    set index = $lf($$$APPCACHE, url)
    if index > 0 return $$ListToJSON(index)
  }
        
  set $namespace = "%SYS"
    
  set result = {}  
  set name = ""
  set urlWithInitialSlash = $select($extract(url) '= "/" : "/"_url, 1: url)
  
  // Revert the ordering so that longer are considered first, note that the longer the path is higher is similarity with the url.
  set rows = ##class(%SQL.Statement).%ExecDirect(, "SELECT TOP 1 Name, DispatchClass, Path FROM SECURITY.APPLICATIONS WHERE ? %STARTSWITH Name ORDER BY LEN(Name) DESC", urlWithInitialSlash)
  if rows.%Next() {
    set $list($$$APPCACHE, *+1) = urlWithInitialSlash
    set index = $ll($$$APPCACHE)
    set name = rows.%Get("Name")
    set $list($$$APPCACHE, *+1) = name  
    set $list($$$APPCACHE, *+1) = rows.%Get("DispatchClass")
    set $list($$$APPCACHE, *+1) = rows.%Get("Path")
    set $list($$$APPCACHE, *+1) = name_$select($extract(name, *) '= "/" : "/", 1: "")
    set result = $$ListToJSON(index)
  }
  
  set $namespace = ..Namespace
  
  if name = "" $$$ThrowStatus($$$ERROR($$$GeneralError, "No application found for url: "_url))
  
  return result
  
ListToJSON(urlIndex)
  return {
    "Name": ($lg($$$APPCACHE, urlIndex + 1)),
    "DispatchClass": ($lg($$$APPCACHE, urlIndex + 2)),
    "Path": ($lg($$$APPCACHE, urlIndex + 3)),
    "AppUrl": ($lg($$$APPCACHE, urlIndex + 4))
  }
]]></Implementation>
</Method>

<Method name="ClearCookies">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%CookiesJar = ""
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Forgery.OutputCapturer">
<Abstract>1</Abstract>
<TimeCreated>64889,32297.316997</TimeCreated>

<Method name="Capture">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>dispatcherClass:%String,url:%String,httpMethod:%String,*str:%Stream.Object</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  new %frontier

  if ##class(%Dictionary.CompiledClass).%ExistsId("Frontier.Context") {
    set %frontier = ##class(Frontier.Context).%New(%session, %request, %response)
  }

  new oldMnemonic, alreadyRedirected, sc

  set sc = $$$OK
  set isRedirected = 0

  set str = ##class(%Stream.GlobalCharacter).%New()
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set oldMnemonic = ##class(%Device).GetMnemonicRoutine()
  set initIO = $io

  try {
    do ##class(%Device).ReDirectIO(1)
    use $io::("^"_$zname)
    set isRedirected = 1
    set sc = $classmethod(dispatcherClass, "DispatchRequest", url, httpMethod)
    do str.Rewind()
  } catch ex {
    set str = ""
    set sc = ex.AsStatus()
  }

  if oldMnemonic '= "" {
    use initIO::("^"_oldMnemonic)
  } else {
    use oldMnemonic
  }

  do ##class(%Device).ReDirectIO(alreadyRedirected)

  return sc

wstr(s) Do str.Write(s) Quit
wchr(a) Do str.Write($char(a)) Quit
wnl Do str.Write($char(13,10)) Quit
wff Do str.Write($char(13,10,13,10)) Quit
wtab(n) Do str.Write($c(9)) Quit
rstr(len,time) Quit ""
rchr(time) Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Forgery.Request">
<Super>%RegisteredObject</Super>
<TimeCreated>64841,38794.441157</TimeCreated>

<Property name="URL">
<Type>%String</Type>
</Property>

<Property name="Method">
<Type>%String</Type>
</Property>

<Property name="Application">
<Type>%String</Type>
</Property>

<Property name="Content">
<Type>%CSP.Stream</Type>
</Property>

<Property name="Cookies">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="MimeData">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ContentType">
<Type>%String</Type>
</Property>

<Property name="ContentLength">
<Type>%String</Type>
</Property>

<Property name="Authorization">
<Type>%String</Type>
</Property>

<Property name="Protocol">
<Type>%String</Type>
<InitialExpression>"HTTP/1.1"</InitialExpression>
</Property>

<Property name="CgiEnvs">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Data">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>url:%String,method:%String="GET"</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..URL = url
  set ..Method = method
  set ..Content = ##class(%CSP.CharacterStream).%New()
  do ..LoadDefaultCgiEnvs()
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateFromSettings">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[settings:%DynamicObject,&cookiesJar:%String=""]]></FormalSpec>
<ReturnType>Forgery.Request</ReturnType>
<Implementation><![CDATA[
  set urlWithoutQueryParams = $piece(settings.url, "?")
  set request = ..%New(urlWithoutQueryParams, settings.method)
  
  if $data(cookiesJar) merge request.Cookies = cookiesJar

  do AppendToRequest("headers", settings.headers)
  do AppendToRequest("cookies", settings.cookies)

  if settings.%IsDefined("headers") {
    if settings.headers.%IsDefined("Authorization") {
      set request.Authorization = settings.headers.Authorization
    }
  }

  if settings.url [ "?" {
    set queryParts = $replace(settings.url, "?", "&")
    for i=2:1:$length(queryParts, "&") {
      set qp = $piece(queryParts, "&", i)
      set qn = $piece(qp, "=", 1)
      set qv = $piece(qp, "=", 2)
      do request.Insert(qn, qv)
    }
  }

  if settings.%IsDefined("data") && $isobject(settings.data) {
    if settings.headers.%Get("Content-Type") [ "multipart/form-data" {
      do AppendToRequest("mimedata", settings.data)
    } elseif settings.data.%IsA("%Stream.Object") {
      if settings.data.IsCharacter() set content = ##class(%CSP.CharacterStream).%New()
      else  set content = ##class(%CSP.BinaryStream).%New()
      do content.CopyFrom(settings.data)
    } elseif settings.data.%Extends("%DynamicAbstractObject") {
      set content = ##class(%CSP.CharacterStream).%New()
      do settings.data.%ToJSON(.content)
      set request.Content = content
      if settings.headers.%Get("Content-Type") '[ "application/json" {
        do request.SetHeader("Content-Type", "application/json")
      }
    } else {
      do AppendToRequest("queryparams", settings.data)
    }
  }

  return request

AppendToRequest(settingName, settingData, parentKey = "")
  if '$isobject(settingData) quit
  set iterator = settingData.%GetIterator()

  while iterator.%GetNext(.key, .val) {
    set appendToKeyName = key
    if $isobject(val) {
      if val.%IsA("%DynamicObject") {
        do AppendToRequest(settingName, val)
      } elseif val.%IsA("%DynamicArray") {
        do AppendToRequest(settingName, val, key)
      }
    } elseif parentKey '= "" {
      set appendToKeyName = parentKey
    }
    if settingName = "headers" { do request.SetHeader(appendToKeyName, val) }
    elseif settingName = "cookies" { do request.InsertCookie(appendToKeyName, val) }
    elseif settingName = "mimedata" { do request.InsertMimeData(appendToKeyName, val) }
    elseif settingName = "queryparams" { do request.Insert(appendToKeyName, val) }
  }
  quit
]]></Implementation>
</Method>

<Method name="AuthorizationSet">
<Final>1</Final>
<FormalSpec>value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%CgiEnvs("HTTP_AUTHORIZATION") = value
  set i%Authorization = value
  return $$$OK
]]></Implementation>
</Method>

<Method name="ContentTypeSet">
<FormalSpec>value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%CgiEnvs("HTTP_CONTENT_TYPE") = value
  set i%ContentType = value
  return $$$OK
]]></Implementation>
</Method>

<Method name="ContentLengthSet">
<FormalSpec>value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%CgiEvs("CONTENT_LENGTH") = value
  set i%ContentLength = value
  return $$$OK
]]></Implementation>
</Method>

<Method name="LoadDefaultCgiEnvs">
<Private>1</Private>
<Implementation><![CDATA[
  do ##class(%Net.URLParser).Parse(..URL, .components)
  do ParseQueryString(components("query"), .data)

  merge i%Data = data

  set i%CgiEnvs("REQUEST_METHOD") = $$$ucase(..Method)
  set i%CgiEnvs("REQUEST_SCHEME") = "http"
  set i%CgiEnvs("REQUEST_URI") = components("path")
  set i%CgiEnvs("SERVER_NAME") = "localhost"
  set i%CgiEnvs("SERVER_PORT") = 57772
  set i%CgiEnvs("SERVER_PROTOCOL") = "HTTP/1.1"

ParseQueryString(qs, data)
  if qs = "" quit

  set qp = $lfs(qs, "&")

  for i=1:1:$ll(qp) {
    set key = $piece($lg(qp, i), "=", 1)
    set value = $piece($lg(qp, i), "=", 2)
    if key '= "" && (value '= "") set data(key, 1) = value
  }
  quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Most of the methods below are a copy from %CSP.Request, since we need to keep

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// these methods working as they can be called by the application.

]]></Content>
</UDLText>

<Method name="GetCookie">
<Description>
Retrieves the named cookie</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,default:%String="",index:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$get(i%Cookies(name,index),default)
]]></Implementation>
</Method>

<Method name="InsertCookie">
<Description>
Inserts a cookie name/value pair.</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String,value:%String</FormalSpec>
<Implementation><![CDATA[
  If name="" Quit $$$OK
  do ..SetCgiEnv("HTTP_"_$$$ucase($replace(name, "-", "_")), value)
  Set i%Cookies(name,$order(i%Cookies(name,""),-1)+1)=value
  Quit
]]></Implementation>
</Method>

<Method name="IsDefinedCookie">
<Description>
Returns true if the named cookie exists in the cookie collection, false otherwise.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,index:%Integer=1</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$data(i%Cookies(name,index))
]]></Implementation>
</Method>

<Method name="GetMimeData">
<Description>
Retrieves the named multipart MIME stream.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,default:%Stream.Object="",index:%Integer=1</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[$get(i%MimeData(name,index),default)
]]></Implementation>
</Method>

<Method name="InsertMimeData">
<Description>
Inserts a multipart MIME stream by name into the collection.</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String,value:%Stream.Object</FormalSpec>
<Implementation><![CDATA[
  If value="" Quit
  Set i%MimeData(name,$order(i%MimeData(name,""),-1)+1)=value
  Quit
]]></Implementation>
</Method>

<Method name="IsDefinedMimeData">
<Description>
Returns true if the named multipart MIME stream exists in the collection, false otherwise.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,index:%Integer=1</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$data(i%MimeData(name,index))
]]></Implementation>
</Method>

<Method name="CountMimeData">
<Description>
Returns the count of multipart MIME streams with this name.</Description>
<Final>1</Final>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  #Dim count,i

  Quit:'$data(i%MimeData(name)) 0
  Set count=0 Set i="" For  Set i=$order(i%MimeData(name,i)) Quit:i=""  Set count=count+1
  Quit count
]]></Implementation>
</Method>

<Method name="NextMimeData">
<Description>
Retrieves name of the next multipart MIME stream stored in the request object.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$order(i%MimeData(name))
]]></Implementation>
</Method>

<Method name="NextMimeDataIndex">
<Description>
Return the index number of the next multipart MIME stream stored in the request object.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,index:%Integer=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$order(i%MimeData(name,index))
]]></Implementation>
</Method>

<Method name="DeleteMimeData">
<Description><![CDATA[
Removes this multipart MIME stream from the collection. Returns the number
of nodes it has removed. If <var>name</var> is not defined then it will
remove the entire set of MimeData, if <var>name</var> is defined but <var>index</var>
is not then it will remove all items stored under <var>name</var>.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String="",index:%Integer=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  #Dim defined
  If name="" {
    Set defined=0
    Set name=$order(i%MimeData(""))
    While name'="" {
      Set index=$order(i%MimeData(name,""))
      While index'="" { Set defined=defined+1,index=$order(i%MimeData(name,index)) }
      Set name=$Order(i%MimeData(name))
    }
    Kill i%MimeData
    Quit defined
  } ElseIf index="" {
    Set defined=0
    Set index=$order(i%MimeData(name,""))
    While index'="" { Set defined=defined+1,index=$order(i%MimeData(name,index)) }
    Kill i%MimeData(name)
    Quit defined
  } ElseIf $Data(i%MimeData(name,index)) {
    Kill i%MimeData(name,index)
    Quit 1
  }
  Quit 0
]]></Implementation>
</Method>

<Method name="SetCgiEnv">
<FormalSpec>key:%String,value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '$data(i%CgiEnvs(key)) set i%CgiEnvs(key) = value
  return $$$OK
]]></Implementation>
</Method>

<Method name="InsertCgiEnv">
<Description>
Inserts a CGI environment variable by name into the collection.</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String,value:%String</FormalSpec>
<Implementation><![CDATA[  do ..SetCgiEnv(name, value)
]]></Implementation>
</Method>

<Method name="GetCgiEnv">
<Description>
Retrieves the named CGI environment variable.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,default:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$get(i%CgiEnvs(name),default)
]]></Implementation>
</Method>

<Method name="IsDefinedCgiEnv">
<Description>
Returns true if the named CGI environment variable exists in the collection, false otherwise.</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$data(i%CgiEnvs(name))
]]></Implementation>
</Method>

<Method name="NextCgiEnv">
<Description>
Retrieves the next CGI environment variable name in the sequence</Description>
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$order(i%CgiEnvs(name))
]]></Implementation>
</Method>

<Method name="DeleteCgiEnv">
<Description>
Removes this CGI environment variable from the collection, returns true if the item
was defined and false if it was never defined.</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  If $data(i%CgiEnvs(name)) Kill i%CgiEnvs(name) Quit 1
  Quit 0
]]></Implementation>
</Method>

<Method name="SetHeader">
<FormalSpec>key:%String,value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $$$lcase(key) = "content-type" set ..ContentType = value
  if $$$lcase(key) = "content-length" set ..ContentLength = value

  do ..SetCgiEnv("HTTP_"_$$$ucase($replace(key, "-", "_")), value)
  return $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,default:%String="",index:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$get(i%Data(name,index),default)
]]></Implementation>
</Method>

<Method name="Set">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>name:%String,value:%String,index:%Integer=1</FormalSpec>
<Implementation><![CDATA[
  If $length(name)>254 Quit
  Set i%Data(name,index)=value
  QUIT
]]></Implementation>
</Method>

<Method name="Insert">
<Final>1</Final>
<FormalSpec>name:%String,value:%String</FormalSpec>
<Implementation><![CDATA[
  If $length(name)>254 Quit
  Set i%Data(name,$order(i%Data(name,""),-1)+1)=value
  Quit
]]></Implementation>
</Method>

<Method name="IsDefined">
<Final>1</Final>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String,index:%Integer=1</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$data(i%Data(name,index))
]]></Implementation>
</Method>

<Method name="Count">
<Final>1</Final>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  #Dim count,i
  Quit:'$data(i%Data(name)) 0
  Set count=0 Set i="" For  Set i=$order(i%Data(name,i)) Quit:i=""  Set count=count+1
  Quit count
]]></Implementation>
</Method>

<Method name="Find">
<Final>1</Final>
<FormalSpec>name:%String,value:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  #Dim i
  Set i=$order(i%Data(name,""))
  While (i'="")&&(i%Data(name,i)'=value) { Set i=$order(i%Data(name,i)) }
  Quit i
]]></Implementation>
</Method>

<Method name="NextIndex">
<Final>1</Final>
<FormalSpec><![CDATA[name:%String,&index:%Integer=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  Set index=$order(i%Data(name,index))
  Quit:index="" ""
  Quit i%Data(name,index)
]]></Implementation>
</Method>
</Class>
</Export>
